{"name":"AbstractFileStore.java","path":"paimon-core/src/main/java/org/apache/paimon/AbstractFileStore.java","content":{"structured":{"description":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: org.apache.paimon.AbstractFileStore&lt; T &gt; Pages: 1 -->\n<svg width=\"193pt\" height=\"148pt\"\n viewBox=\"0.00 0.00 193.00 148.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 144)\">\n<title>org.apache.paimon.AbstractFileStore&lt; T &gt;</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"169.5,-30 15.5,-30 15.5,0 169.5,0 169.5,-30\"/>\n<text text-anchor=\"start\" x=\"23.5\" y=\"-18\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">org.apache.paimon.Abstract</text>\n<text text-anchor=\"middle\" x=\"92.5\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">FileStore&lt; T &gt;</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"interfaceorg_1_1apache_1_1paimon_1_1FileStore.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"185,-85 0,-85 0,-66 185,-66 185,-85\"/>\n<text text-anchor=\"middle\" x=\"92.5\" y=\"-73\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">org.apache.paimon.FileStore&lt; T &gt;</text>\n</a>\n</g>\n</g>\n<!-- Node2&#45;&gt;Node1 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node2&#45;&gt;Node1</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M92.5,-55.65C92.5,-47.36 92.5,-37.78 92.5,-30.11\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"89,-55.87 92.5,-65.87 96,-55.87 89,-55.87\"/>\n</a>\n</g>\n</g>\n<!-- Node3 -->\n<g id=\"Node000003\" class=\"node\">\n<title>Node3</title>\n<g id=\"a_Node000003\"><a xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"129.5,-140 55.5,-140 55.5,-121 129.5,-121 129.5,-140\"/>\n<text text-anchor=\"middle\" x=\"92.5\" y=\"-128\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">Serializable</text>\n</a>\n</g>\n</g>\n<!-- Node3&#45;&gt;Node2 -->\n<g id=\"edge2_Node000002_Node000003\" class=\"edge\">\n<title>Node3&#45;&gt;Node2</title>\n<g id=\"a_edge2_Node000002_Node000003\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M92.5,-110.66C92.5,-101.93 92.5,-91.99 92.5,-85.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"89,-110.75 92.5,-120.75 96,-110.75 89,-110.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","items":[{"id":"569ac442-6f65-528b-aa49-a66d454c65b6","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a `FileStorePathFactory` instance that generates file paths based on user-defined options, including the partition type and default name, as well as the format identifier of the file format used by the system.","params":[],"returns":{"type_name":"FileStorePathFactory","description":"a `FileStorePathFactory` object that creates file store paths based on user-defined options.\n\n* `options`: The options object containing configuration parameters for the file store path factory.\n* `path`: The base path for the file store.\n* `partitionType`: The type of partitioning used for the file store (e.g., \"leaf\", \"non-leaf\").\n* `partitionDefaultName`: The default name of a partition in the file store, if applicable.\n* `fileFormat`: The file format used by the file store, which contains information about the format identifier.","complex_type":true},"usage":{"language":"java","code":"FileStorePathFactory factory = new FileStorePathFactory(\n                options.path(),\n                partitionType,\n                options.partitionDefaultName(),\n                options.fileFormat().getFormatIdentifier());\n","description":"\nIn this example, the variable factory is assigned a value of a new `FileStorePathFactory` object created using parameters obtained from an instance of `CoreOptions`. The parameters are:\n* `options.path()`: A directory path on the file system where the table data is stored. This can be specified in the `CREATE TABLE` statement when creating the table, or it defaults to a temporary location if not specified.\n* `partitionType`: A partitioning scheme for the table.\n* `options.partitionDefaultName()`: The default name for partitions.\n* `options.fileFormat().getFormatIdentifier()`: The format of data stored in the table.\n\nThe path factory can then be used to create paths and file names for various purposes, such as creating a manifest file or an index file. For example:\n"},"name":"pathFactory","code":"@Override\n    public FileStorePathFactory pathFactory() {\n        return new FileStorePathFactory(\n                options.path(),\n                partitionType,\n                options.partitionDefaultName(),\n                options.fileFormat().getFormatIdentifier());\n    }","location":{"start":96,"insert":96,"offset":" ","indent":4,"comment":null},"item_type":"method","length":8,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"1bfeaf9a-3f3f-1996-8b47-688b3dc4983d","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates an instance of `SnapshotManager` using `fileIO` and the path provided by `options.path()`. The resulting `SnapshotManager` object manages snapshot-related operations for the application.","params":[],"returns":{"type_name":"SnapshotManager","description":"an instance of the `SnapshotManager` class, which manages snapshots for a given path.\n\n* `fileIO`: This is an instance of `FileIO`, which provides methods for reading and writing files.\n* `path`: This is the path to the snapshot file specified by the options.\n* `SnapshotManager`: This is a class that manages snapshots, providing methods for creating, deleting, and retrieving snapshots.","complex_type":true},"usage":{"language":"java","code":"@Override\npublic SnapshotManager snapshotManager() {\n    return new SnapshotManager(fileIO, options.path());\n}\n","description":"\nThis creates a new instance of the SnapshotManager class that uses the fileIO object and the options.path string to initialize its fields and methods.\n\nThe method is called in other parts of the codebase to get access to an instance of the SnapshotManager class, which provides various functionality related to storing and managing snapshots of a table's data. For example, the method can be used to create a new snapshot or retrieve information about existing snapshots.\n\nIt is worth noting that this method is part of a larger class, AbstractFileStore, which provides access to other functionality related to working with files and file systems in the context of a table's data. However, it is only one method from that class that is exposed as part of its API."},"name":"snapshotManager","code":"@Override\n    public SnapshotManager snapshotManager() {\n        return new SnapshotManager(fileIO, options.path());\n    }","location":{"start":105,"insert":105,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"12d6ebfa-18c3-7eb1-b947-fffbc3af54d0","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"returns a `ManifestFile.Factory` instance for creating `ManifestFile` objects with the specified `true` or `false` argument indicating whether the manifest file should be generated for the main class or not.","params":[],"returns":{"type_name":"ManifestFileFactory","description":"a `ManifestFile.Factory` object that creates a new instance of `ManifestFile`.\n\n* The `ManifestFile.Factory` object represents an interface for creating manifest files.\n* The `return` statement specifies that the factory should return an instance of this interface.\n* The `false` parameter passed to the `manifestFileFactory` function indicates that the returned manifest file will not be read-only.","complex_type":true},"usage":{"language":"java","code":"public class FileStore {\n    public ManifestFile.Factory manifestFileFactory() {\n        return new ManifestFile.Factory(options().manifestFormat(), pathFactory());\n    }\n}\n","description":"\nThis code creates a new instance of ManifestFile.Factory using the manifest format and path factory provided by the options.\nIt is important to note that this method is not directly used in the code, but rather it is called from other methods that use the returned value.\nFor example:\n"},"name":"manifestFileFactory","code":"@Override\n    public ManifestFile.Factory manifestFileFactory() {\n        return manifestFileFactory(false);\n    }","location":{"start":110,"insert":110,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"b37ec13b-2c8f-fbbf-344b-458ad9e144a4","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a `ManifestFile.Factory` instance to generate or update manifest files based on input parameters such as file I/O, schema manager, partition type, and options for manifest format, path factory, and target size.","params":[{"name":"forWrite","type_name":"boolean","description":"whether the factory should create manifest files for write or read-only access.","complex_type":false}],"returns":{"type_name":"ManifestFileFactory","description":"a `ManifestFile.Factory` instance, which provides methods for creating and manipulating manifest files.\n\n* `fileIO`: The File IO interface for reading and writing files.\n* `schemaManager`: A schema manager for managing XML schemas.\n* `partitionType`: The type of partition being created (e.g., `PARTITION`).\n* `options.manifestFormat()`: The manifest format to use (e.g., `MANIFEST_1_0`).\n* `pathFactory()`: A path factory for generating paths.\n* `options.manifestTargetSize().getBytes()`: The target size of the manifest file in bytes.\n* `forWrite`: A boolean indicating whether the manifest file is being created for writing or reading.","complex_type":true},"usage":{"language":"java","code":"// forWrite = true\nManifestFile.Factory mf1 = manifestFileFactory(true);\n\n// forWrite = false\nManifestFile.Factory mf2 = manifestFileFactory(false);\n","description":"\nThe first argument in the method is a boolean called forWrite, which determines whether the method is being used to write to the Manifest file or not. If true, then the method will create a new instance of the ManifestFile class with the necessary parameters for writing to the file. Otherwise, if false, then it will create a new instance of the ManifestFile class with the necessary parameters for reading from the file.\n\nThe code is short and simple to understand. The method simply takes in a boolean and returns an instance of the ManifestFile class depending on whether it was written to or not."},"name":"manifestFileFactory","code":"protected ManifestFile.Factory manifestFileFactory(boolean forWrite) {\n        return new ManifestFile.Factory(\n                fileIO,\n                schemaManager,\n                partitionType,\n                options.manifestFormat(),\n                pathFactory(),\n                options.manifestTargetSize().getBytes(),\n                forWrite ? writeManifestCache : null);\n    }","location":{"start":115,"insert":115,"offset":" ","indent":4,"comment":null},"item_type":"method","length":10,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"5efb7a13-cd9d-269a-da43-142b2e22ec41","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"generates a `ManifestList.Factory` object that produces instances of `ManifestList` with an empty list of manifests when the parameter `includeDefaultManifest` is set to `false`.","params":[],"returns":{"type_name":"ManifestListFactory","description":"a `ManifestList.Factory` object that represents a factory for creating instances of the `ManifestList` class with a false value for the `addToManifest` method.\n\n* The ` Factory` object returned is of type `ManifestList.Factory`.\n* The `false` argument passed to the function indicates that the factory should not create a new manifest list when it is used.","complex_type":true},"usage":{"language":"java","code":"@Override\npublic ManifestList.Factory manifestListFactory() {\n    return new ManifestList.Factory(fileIO, options.manifestFormat(), pathFactory());\n}\n","description":"\nHere's the explanation: \n\n* The method manifestListFactory returns a ManifestList.Factory object that is an implementation of the interface ManifestList.Factory.\n* It takes three arguments: 1) fileIO: This argument is provided by the user and allows to read and write files. It can be used as a FileIO object.\n* options.manifestFormat(): This argument is also provided by the user and it provides information about how to format the ManifestFile, such as its structure and how to parse its content.\n* pathFactory(): This argument returns an instance of the PathFactory class that is responsible for generating file names and paths. It is used to create a manifest list file."},"name":"manifestListFactory","code":"@Override\n    public ManifestList.Factory manifestListFactory() {\n        return manifestListFactory(false);\n    }","location":{"start":126,"insert":126,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"0dab0e42-b856-f19e-b34c-e3d057dbfb0e","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a `ManifestList.Factory` instance, which is used to generate manifest files, with options for writing or reading the manifest files.","params":[{"name":"forWrite","type_name":"boolean","description":"whether the manifest list is being created for read or write access, and it determines the cache to be used when creating the manifest list.","complex_type":false}],"returns":{"type_name":"ManifestListFactory","description":"a `ManifestList.Factory` object that creates and manipulates manifest files for various purposes.\n\n* `fileIO`: A reference to an interface for handling file input/output operations.\n* `options.manifestFormat()`: A reference to a method that returns a manifest format string.\n* `pathFactory()`: A reference to a method that returns a path factory object.\n* `forWrite ? writeManifestCache : null`: If `forWrite` is `true`, the `writeManifestCache` value is returned, otherwise it is `null`.","complex_type":true},"usage":{"language":"java","code":"boolean forWrite = true; // or false\nManifestList.Factory factory = manifestListFactory(forWrite);\n// ... Use the factory here ...\n","description":"\nNote that this code uses a parameter `forWrite` which determines whether the created manifest list is intended to be written to (i.e., `true`) or read from (`false`).  This method returns a new instance of `ManifestList.Factory`, which can then be used to create a new `ManifestList` object for reading or writing."},"name":"manifestListFactory","code":"protected ManifestList.Factory manifestListFactory(boolean forWrite) {\n        return new ManifestList.Factory(\n                fileIO,\n                options.manifestFormat(),\n                pathFactory(),\n                forWrite ? writeManifestCache : null);\n    }","location":{"start":131,"insert":131,"offset":" ","indent":4,"comment":null},"item_type":"method","length":7,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"7338eae5-ea1b-97b2-3f48-adb2cd40a565","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a new instance of `IndexManifestFile.Factory`, which is responsible for generating and managing manifest files for the application.","params":[],"returns":{"type_name":"IndexManifestFileFactory","description":"an instance of `IndexManifestFile.Factory`.\n\n* `fileIO`: This is an instance of `FileIO`, which represents the file input and output operations for the manifest file.\n* `manifestFormat`: This is a format string that specifies the structure of the manifest file.\n* `pathFactory`: This is a function that generates a path to the manifest file.\n\nOverall, this function returns an instance of `IndexManifestFile.Factory`, which provides a way to create and manipulate `IndexManifestFile` objects.","complex_type":true},"usage":{"language":"java","code":"IndexManifestFile.Factory factory = new FileStore(...).indexManifestFileFactory();\nIndexManifestFile manifestFile = factory.create(manifest);\n","description":"\nThis creates a new instance of IndexManifestFile with the given manifest file name (a string that contains the path to the manifest file) and returns it."},"name":"indexManifestFileFactory","code":"protected IndexManifestFile.Factory indexManifestFileFactory() {\n        return new IndexManifestFile.Factory(fileIO, options.manifestFormat(), pathFactory());\n    }","location":{"start":139,"insert":139,"offset":" ","indent":4,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"b0a777c7-19e6-5781-b74c-b3d210fd9c3c","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates an instance of the `IndexFileHandler` class, which handles various aspects of indexing files, including snapshot management, file manipulation, and index creation using `HashIndexFile` and `DeletionVectorsIndexFile`.","params":[],"returns":{"type_name":"IndexFileHandler","description":"an instance of `IndexFileHandler`, which provides a way to manage and manipulate index files.\n\n* `snapshotManager()`: This represents the snapshot manager, which is responsible for managing the creation and updating of snapshots.\n* `pathFactory().indexFileFactory()`: This refers to the index file factory, which is used to create the index files.\n* `indexManifestFileFactory().create()`: This represents the index manifest file factory, which creates the index manifest file.\n* `new HashIndexFile(fileIO, pathFactory().indexFileFactory())`: This creates a new instance of the hash index file, which is used to store the contents of the index files in a compact and efficient manner.\n* `new DeletionVectorsIndexFile(fileIO, pathFactory().indexFileFactory())`: This creates a new instance of the deletion vectors index file, which stores information about the deletion of documents in the index.","complex_type":true},"usage":{"language":"java","code":"@Override\n    public IndexFileHandler newIndexFileHandler() {\n        return new IndexFileHandler(\n                snapshotManager(),\n                pathFactory().indexFileFactory(),\n                indexManifestFileFactory().create(),\n                new HashIndexFile(fileIO, pathFactory().indexFileFactory()),\n                new DeletionVectorsIndexFile(fileIO, pathFactory().indexFileFactory()));\n    }\n","description":"\nThis method is used to create a new instance of the IndexFileHandler class. The method takes no arguments and returns an object of type IndexFileHandler. This object will be used for reading and writing index files within the file store. The method creates several instances of classes that implement the IndexFile interface, such as HashIndexFile and DeletionVectorsIndexFile. These objects are then passed to the constructor of the IndexFileHandler class, which uses them to read and write data to and from index files in the file store.\n\nThe purpose of this method is to provide a new instance of the IndexFileHandler class for use in reading and writing index files within the file store. The IndexFileHandler class is responsible for reading and writing index files, and the purpose of this method is to create an object of this class for use in these operations.\n\nThis example code creates a new instance of the IndexFileHandler class, which takes no arguments and returns an object of type IndexFileHandler. This object will be used for reading and writing index files within the file store. The code then creates several instances of classes that implement the IndexFile interface, such as HashIndexFile and DeletionVectorsIndexFile. These objects are then passed to the constructor of the IndexFileHandler class, which uses them to read and write data to and from index files in the file store.\n\nThe purpose of this example code is to demonstrate how the newIndexFileHandler method can be used to create a new instance of the IndexFileHandler class for use in reading and writing index files within the file store. The IndexFileHandler class is responsible for reading and writing index files, and the purpose of this example code is to show how to use this class in these operations."},"name":"newIndexFileHandler","code":"@Override\n    public IndexFileHandler newIndexFileHandler() {\n        return new IndexFileHandler(\n                snapshotManager(),\n                pathFactory().indexFileFactory(),\n                indexManifestFileFactory().create(),\n                new HashIndexFile(fileIO, pathFactory().indexFileFactory()),\n                new DeletionVectorsIndexFile(fileIO, pathFactory().indexFileFactory()));\n    }","location":{"start":143,"insert":143,"offset":" ","indent":4,"comment":null},"item_type":"method","length":9,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"8f2c9223-bb46-afb7-3440-b2154d1b1a20","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a new instance of `StatsFileHandler`, which is responsible for handling statistical data files. The function returns an instance of `StatsFileHandler` that includes a `snapshotManager`, `schemaManager`, and a `StatsFile` object for reading and writing statistical data to a file.","params":[],"returns":{"type_name":"StatsFileHandler","description":"a new instance of the `StatsFileHandler` class, which provides functionality for handling statistics files.\n\n* `snapshotManager()`: This is a reference to a SnapshotManager object, which manages the creation and modification of snapshots.\n* `schemaManager`: This is a reference to a SchemaManager object, which manages the schema of the data being handled by the StatsFileHandler.\n* `StatsFile`: This is an instance of the StatsFile class, which represents the file handle for the statistics file. The `fileIO` and `pathFactory()` arguments passed to the constructor provide the file input/output operations and the path factory for the file.","complex_type":true},"usage":{"language":"java","code":"StatsFileHandler statsFileHandler = fileStore.newStatsFileHandler();\nstatsFileHandler.addValue(0, 10L);\nstatsFileHandler.addValue(2, 3.5D);\nstatsFileHandler.commit();\n","description":"\nIn this example, a new StatsFileHandler instance is created and used to add two values to the stats file. Finally, the commit method is called on the object to ensure that any changes made are persisted to disk."},"name":"newStatsFileHandler","code":"@Override\n    public StatsFileHandler newStatsFileHandler() {\n        return new StatsFileHandler(\n                snapshotManager(),\n                schemaManager,\n                new StatsFile(fileIO, pathFactory().statsFileFactory()));\n    }","location":{"start":153,"insert":153,"offset":" ","indent":4,"comment":null},"item_type":"method","length":7,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"dfd7191f-310c-f3a5-6c4b-f2fdd2aca742","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"returns the `RowType` value assigned to it by its class.","params":[],"returns":{"type_name":"RowType","description":"a `RowType`.\n\nThe RowType object is an instance of the RowType class, which represents a table row in the database. The partition type determines how the data is divided and stored in the table.\nThe return value of this function is always of type RowType, indicating that it returns a single row of data that has been partitioned according to some scheme.\nNo additional information about the code or its author is provided beyond what is strictly necessary to answer the question at hand.","complex_type":true},"usage":{"language":"java","code":"@Override\n    public RowType partitionType() {\n        return partitionType;\n    }\n","description":"\nThis method would be called by any class that inherits from this abstract class, and it will allow the class to access the partition type that was set in the options when the FileStore object was created. This allows for easy retrieval of the partition type without needing to create an entirely new instance of the FileStore object just to get the partition type back."},"name":"partitionType","code":"@Override\n    public RowType partitionType() {\n        return partitionType;\n    }","location":{"start":161,"insert":161,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"c6b894cb-643b-3ca7-1744-ce58aba42726","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"returns a `CoreOptions` object, which is an instance of a class that provides access to various options related to the Java runtime environment.","params":[],"returns":{"type_name":"CoreOptions","description":"a `CoreOptions` object containing the configuration settings for the Java application.\n\nThe `CoreOptions` object is a instance of the class `CoreOptions`.\nIt has a field named `options`, which is also of type `CoreOptions`.\nThis means that the returned output is an instance of the same class as the original input.\nThe field `options` contains the original options passed to the function.","complex_type":true},"usage":{"language":"java","code":"CoreOptions options = new CoreOptions(path);\noptions.withBucket(\"bucket\");\nFileStore fileStore = FileStore.create(fileIO, schemaManager, tableSchema, options, catalogEnvironment);\n","description":"\nThis code creates an instance of a `FileStore` with the path to the base directory passed as an argument to the constructor, and sets the bucket name using the `withBucket()` method on the instance returned by the method."},"name":"options","code":"@Override\n    public CoreOptions options() {\n        return options;\n    }","location":{"start":166,"insert":166,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"647a0e72-88d3-daa7-fd4e-7921145eeef7","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"takes a `RowType` object and a boolean parameter, `allowExplicitCast`, and merges the schema with the provided arguments. It returns a boolean value indicating whether the merge was successful.","params":[{"name":"rowType","type_name":"RowType","description":"type of row that is being merged.\n\nRowType rowType is an object that contains attributes. \nThe `allowExplicitCast` argument indicates whether or not explicit casting can be performed during schema merging.\nThe method `mergeSchema` returns a boolean value indicating whether the schema merge operation was successful or not.","complex_type":true},{"name":"allowExplicitCast","type_name":"boolean","description":"ability to perform an explicit cast when merging schemas.","complex_type":false}],"returns":{"type_name":"boolean","description":"a boolean value indicating whether the merge operation was successful.","complex_type":false},"usage":{"language":"java","code":"@Override\n    public boolean mergeSchema(RowType rowType, boolean allowExplicitCast) {\n        return schemaManager.mergeSchema(rowType, allowExplicitCast);\n    }\n\n// Example usage\n// Create a new RowType with the partition fields as the first columns\nfinal RowType partitionRowType = new RowType()\n        .withFieldsOfType(FieldTypes.ofPrimitiveTypeName(\"INT\").withNullable(true));\n// Create a new FileStore instance\nFileStore fileStore = newFileStore(...);\n// Merge the schema with the new partition type\nfileStore.mergeSchema(partitionRowType, true);\n","description":""},"name":"mergeSchema","code":"@Override\n    public boolean mergeSchema(RowType rowType, boolean allowExplicitCast) {\n        return schemaManager.mergeSchema(rowType, allowExplicitCast);\n    }","location":{"start":171,"insert":171,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"a2c5d68f-fb30-e9b4-ea45-8cb96e2626c9","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a new commit object for the given user and default main branch.","params":[{"name":"commitUser","type_name":"String","description":"user who will commit the changes to the file store.","complex_type":false}],"returns":{"type_name":"FileStoreCommitImpl","description":"a `FileStoreCommitImpl` instance.\n\n1. `FileStoreCommitImpl`: This is the type of object that is returned by the function, which represents a commit in a file store.\n2. `commitUser`: This is the user who committed the changes, as specified in the function parameter.\n3. `DEFAULT_MAIN_BRANCH`: This is the default main branch of the repository where the commit takes place, as specified in the function parameter.","complex_type":true},"usage":{"language":"java","code":"FileStoreCommitImpl commit = fileStore.newCommit(\"John Doe\");\n","description":"\nIn this example, the commitUser argument is a String object that represents the name of the person committing the change. The DEFAULT_MAIN_BRANCH constant is then passed as the second argument to newCommit, which is not used in this example. Therefore, the call to newCommit would create a FileStoreCommitImpl with \"John Doe\" as the commit user and the default main branch name."},"name":"newCommit","code":"@Override\n    public FileStoreCommitImpl newCommit(String commitUser) {\n        return newCommit(commitUser, DEFAULT_MAIN_BRANCH);\n    }","location":{"start":176,"insert":176,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"3baddb63-a99e-9ca0-4e4b-79db4346ab24","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a new commit instance for a file store, providing various inputs such as user name, branch name, and configuration options. It returns a new commit instance with the required components.","params":[{"name":"commitUser","type_name":"String","description":"user who committed the changes to the file store.","complex_type":false},{"name":"branchName","type_name":"String","description":"name of the branch to which the commit belongs.","complex_type":false}],"returns":{"type_name":"FileStoreCommitImpl","description":"a new instance of `FileStoreCommitImpl`.\n\n* `fileIO`: Represents an object that provides file input and output operations.\n* `schemaManager`: Manages schemas for data stored in the commit.\n* `commitUser`: The user who committed the data.\n* `partitionType`: Indicates the type of partitioning used for storing data in the commit.\n* `pathFactory()`: Creates paths for files and directories within the commit.\n* `snapshotManager()`: Manages snapshots for the commit.\n* `manifestFileFactory()`: Creates manifest files for the commit.\n* `manifestListFactory()`: Creates lists of manifest files for the commit.\n* `indexManifestFileFactory()`: Creates index manifest files for the commit.\n* `newScan()`: Represents a new scan instance for the commit.\n* `options`: Stores configuration options for the commit, including bucket, manifest target size, full compaction threshold size, merge minimum count, and dynamic partition overwrite.\n* `keyComparator`: Compares keys for efficient data storage and retrieval within the commit.\n* `branchName`: The name of the branch on which the data is committed.\n* `statsFileHandler`: Provides statistics related to the commit.","complex_type":true},"usage":{"language":"java","code":"FileStore fs = ...; // initialize the FileStore\nString commitUser = \"user1\"; // user to create a commit with\nString branchName = \"main\" // name of the branch to create the commit in\n\n// create a new commit using the specified parameters\nFileStoreCommitImpl commit = fs.newCommit(commitUser, branchName);\n","description":"\nHere, we initialize an instance of FileStore called `fs`, and then use method `newCommit` to create a new commit with user \"user1\" in the main branch (specified by parameter `branchName`). The resulting `FileStoreCommitImpl` object is stored in the variable `commit`.\n\nThis example uses the default values for all parameters, except for `commitUser`, which has been set to \"user1\". The other parameters are all left with their default values, as defined in `AbstractFileStore.options()`."},"name":"newCommit","code":"public FileStoreCommitImpl newCommit(String commitUser, String branchName) {\n        return new FileStoreCommitImpl(\n                fileIO,\n                schemaManager,\n                commitUser,\n                partitionType,\n                pathFactory(),\n                snapshotManager(),\n                manifestFileFactory(),\n                manifestListFactory(),\n                indexManifestFileFactory(),\n                newScan(),\n                options.bucket(),\n                options.manifestTargetSize(),\n                options.manifestFullCompactionThresholdSize(),\n                options.manifestMergeMinCount(),\n                partitionType.getFieldCount() > 0 && options.dynamicPartitionOverwrite(),\n                newKeyComparator(),\n                branchName,\n                newStatsFileHandler());\n    }","location":{"start":181,"insert":181,"offset":" ","indent":4,"comment":null},"item_type":"method","length":21,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"6ce7a37d-6693-9cab-aa4b-90f0b1da7b73","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a `SnapshotDeletion` object that provides file management and metadata services for snapshot deletion. It takes inputs from various factory methods and returns a fully configured `SnapshotDeletion` instance.","params":[],"returns":{"type_name":"SnapshotDeletion","description":"a `SnapshotDeletion` object containing various components for managing snapshots.\n\n* `fileIO`: Represents the file input/output operations for snapshot deletion.\n* `pathFactory()`: Creates paths for snapshot deletion.\n* `manifestFileFactory().create()`: Creates a manifest file for snapshot deletion.\n* `manifestListFactory().create()`: Creates a list of manifest files for snapshot deletion.\n* `newIndexFileHandler()`: Handles the creation of an index file for snapshot deletion.\n* `newStatsFileHandler()`: Handles the creation of a stats file for snapshot deletion.","complex_type":true},"usage":{"language":"java","code":"FileStore store = ...;\nSnapshotDeletion deletion = store.newSnapshotDeletion();\ndeletion.delete(snapshot);\n","description":"\nThis method creates a new instance of SnapshotDeletion and uses it to delete the given snapshot. The first parameter of delete is a snapshot, which needs to be an instance of Snapshot. This will remove the snapshot from the file store."},"name":"newSnapshotDeletion","code":"@Override\n    public SnapshotDeletion newSnapshotDeletion() {\n        return new SnapshotDeletion(\n                fileIO,\n                pathFactory(),\n                manifestFileFactory().create(),\n                manifestListFactory().create(),\n                newIndexFileHandler(),\n                newStatsFileHandler());\n    }","location":{"start":203,"insert":203,"offset":" ","indent":4,"comment":null},"item_type":"method","length":10,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"ae8927f2-20f3-f182-0745-1c1a5e70b190","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a new instance of the `TagManager` class, providing an instance of the `FileIO` class and the path to the options file as parameters.","params":[],"returns":{"type_name":"TagManager","description":"a new instance of the `TagManager` class, which manages tags for a website.\n\n* `fileIO`: Represents the file input/output operations for managing tags.\n* `path()`: Provides the path to the location where the tags will be stored.\n* The return type is `TagManager`, which indicates that it returns an instance of a class that manages tags.","complex_type":true},"usage":{"language":"java","code":"public class MyFileStore extends AbstractFileStore {\n\n    @Override\n    public TagManager newTagManager() {\n        return new TagManager(fileIO, options.path());\n    }\n}\n\n// Later in the code\nMyFileStore myFileStore = ...; // instantiate a file store\nTagManager tagManager = myFileStore.newTagManager(); // create a TagManager object\n","description":"\nNote that the `fileIO` and `options` are passed to the constructor of the `TagManager`. This is because the `TagManager` needs access to these values in order to properly initialize itself. The `MyFileStore` class should have an instance variable for both, which should be assigned before the creation of a `TagManager`.\n\nAlternatively, the method could be modified to accept parameters for both `fileIO` and `options`, as seen below:\n"},"name":"newTagManager","code":"@Override\n    public TagManager newTagManager() {\n        return new TagManager(fileIO, options.path());\n    }","location":{"start":214,"insert":214,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"2408121f-a220-b4ba-534c-72f145a6c68f","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a new instance of the `TagDeletion` class, providing various components required for tag deletion, such as file I/O, path factory, manifest file, and index and stats file handlers.","params":[],"returns":{"type_name":"TagDeletion","description":"a `TagDeletion` object containing various factory methods for file IO, manifest files, and index and stats files.\n\n* `fileIO`: Represents an instance of the `FileIO` class, which provides methods for reading and writing files.\n* `pathFactory()`: Creates an instance of a `PathFactory` class, which provides methods for generating paths based on various input parameters.\n* `manifestFileFactory().create()`: Returns an instance of a `ManifestFile` class, which represents the manifest file for the tag deletion operation.\n* `manifestListFactory().create()`: Creates an instance of a `ManifestList` class, which stores the manifest files for the tag deletion operation.\n* `newIndexFileHandler()`: Represents an instance of the `NewIndexFileHandler` class, which provides methods for handling the index file related to the tag deletion operation.\n* `newStatsFileHandler()`: Represents an instance of the `NewStatsFileHandler` class, which provides methods for handling the stats file related to the tag deletion operation.","complex_type":true},"usage":{"language":"java","code":"FileStore fileStore = ...;\nTagDeletion tagDeletion = fileStore.newTagDeletion();\ntagDeletion.deleteTags(tagsToDelete);\n","description":"\nHere, the `tagsToDelete` is a list of strings representing the tags to be deleted. The `newTagDeletion()` method creates an instance of the class TagDeletion using the parameters provided in the options of the FileStore and returns it as a tag deletion object. The deleteTags method is then called on this object with the tags that need to be deleted and the tag deletion object takes care of deleting these tags. \nThe `newTagDeletion()` method is an example of how to use the method newTagDeletion().\n\nHere is a more complete example:\n"},"name":"newTagDeletion","code":"@Override\n    public TagDeletion newTagDeletion() {\n        return new TagDeletion(\n                fileIO,\n                pathFactory(),\n                manifestFileFactory().create(),\n                manifestListFactory().create(),\n                newIndexFileHandler(),\n                newStatsFileHandler());\n    }","location":{"start":219,"insert":219,"offset":" ","indent":4,"comment":null},"item_type":"method","length":10,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"f06f8fa3-3714-e891-2f49-0185895a0ac5","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a `PartitionExpire` object representing a partition expiration. It takes a commit user and uses the options to determine the partition type, expiration time, check interval, timestamp pattern, formatter, and scanner.","params":[{"name":"commitUser","type_name":"String","description":"username of the user who committed the transaction that created the partition, and is used to set the timestamp of the partition's expiration based on the user's identity.","complex_type":false}],"returns":{"type_name":"PartitionExpire","description":"a `PartitionExpire` object containing various parameters related to partitioning and expiration.\n\n* `partitionType()` represents the type of the partition being created.\n* `partitionExpireTime` is the duration of the partition's expiration time.\n* `partitionExpireCheckInterval` is the interval at which the partition's expiration time is checked.\n* `partitionTimestampPattern()` and `partitionTimestampFormatter()` define how the partition's timestamp is formatted and interpreted.\n* `newScan()` represents the result of a new scan operation performed on the partition.\n* `newCommit(commitUser)` represents the result of a new commit operation performed on the partition with the specified `commitUser`.","complex_type":true},"usage":{"language":"java","code":"@Override\npublic void expire() {\n    // Create a file store and get the commit user\n    FileStore fileStore = ...;\n    String commitUser = ...;\n\n    // Create the partition expire object using the commit user\n    PartitionExpire partitionExpire = fileStore.newPartitionExpire(commitUser);\n    \n    // Start the partition expire process\n    partitionExpire.start();\n}\n","description":"\nThis code will create a new FileStore and then use it to create a new PartitionExpire object using the commit user passed in as a string. It will then start the partition expiration process by calling the start method on the PartitionExpire object."},"name":"newPartitionExpire","code":"@Override\n    @Nullable\n    public PartitionExpire newPartitionExpire(String commitUser) {\n        Duration partitionExpireTime = options.partitionExpireTime();\n        if (partitionExpireTime == null || partitionType().getFieldCount() == 0) {\n            return null;\n        }\n\n        return new PartitionExpire(\n                partitionType(),\n                partitionExpireTime,\n                options.partitionExpireCheckInterval(),\n                options.partitionTimestampPattern(),\n                options.partitionTimestampFormatter(),\n                newScan(),\n                newCommit(commitUser));\n    }","location":{"start":232,"insert":232,"offset":" ","indent":4,"comment":null},"item_type":"method","length":17,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"34d48519-043f-e580-fa41-39d1f0ffdfa6","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a TagAutoManager instance with options, snapshot manager, new tag manager, new tag deletion, and create tag callbacks.","params":[],"returns":{"type_name":"instance","description":"an instance of `TagAutoManager`.\n\n* `options`: an instance of `TagAutoManagerOptions` representing the configuration for managing tags.\n* `snapshotManager`: an instance of `SnapshotManager` providing a way to manage snapshots.\n* `newTagManager`: an instance of `TagManager` responsible for creating new tags.\n* `newTagDeletion`: an instance of `TagDeletion` representing the ability to delete tags.\n* `createTagCallbacks`: an instance of `CreateTagCallbacks` providing callbacks for creating new tags.","complex_type":true},"usage":{"language":"java","code":"TagAutoManager manager = fileStore.newTagCreationManager();\nmanager.createTag(\"tagName\");\n","description":"\nHere, we first create a TagAutoManager instance using the file store's newTagCreationManager() method. We then invoke the createTag() method of the manager object with the tag name \"tagName\". This will cause the manager to create the tag automatically using the TagCallbacks provided by this FileStore implementation.\n\nNote that, in this example, we are using a default constructor for the TagAutoManager class, which requires three arguments: an options instance, a snapshot manager, and a tag manager. The latter two can be obtained from the file store object as shown above. Therefore, we first call the newTagManager() method on the file store to get the tag manager instance, and then pass it to the TagAutoManager constructor along with the other arguments."},"name":"newTagCreationManager","code":"@Override\n    public TagAutoManager newTagCreationManager() {\n        return TagAutoManager.create(\n                options,\n                snapshotManager(),\n                newTagManager(),\n                newTagDeletion(),\n                createTagCallbacks());\n    }","location":{"start":250,"insert":250,"offset":" ","indent":4,"comment":null},"item_type":"method","length":9,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"b1de45e9-425f-4b89-ea45-e367f4870053","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a list of tag callbacks based on the options provided, and adds an additional callback to partition the data if necessary.","params":[],"returns":{"type_name":"ArrayList","description":"a list of tag callbacks, including an additional callback for adding partition tags.\n\n* The list of tag callbacks, which is an instance of `List<TagCallback>`. This list contains all the tag callbacks that are to be executed during the ETL process.\n* The `metastoreClientFactory`, which is an instance of `MetastoreClient.Factory`. This variable represents the client factory used to create a metastore client, which is required for adding partition tags to the data.\n* The `partitionField`, which is a string representing the field that contains the partition information for the data. If this variable is not null, it means that partitioning is enabled for the data, and a tag callback is added to the list to add the partition tag to the data.\n\nIn summary, the `createTagCallbacks` function returns a list of tag callbacks that are used during the ETL process to perform various operations on the data, including adding partition tags if enabled.","complex_type":true},"usage":{"language":"java","code":"@Override\n    public List<TagCallback> createTagCallbacks() {\n        List<TagCallback> callbacks = new ArrayList<>(CallbackUtils.loadTagCallbacks(options));\n        String partitionField = options.tagToPartitionField();\n        MetastoreClient.Factory metastoreClientFactory =\n                catalogEnvironment.metastoreClientFactory();\n        if (partitionField != null && metastoreClientFactory != null) {\n            callbacks.add(\n                    new AddPartitionTagCallback(metastoreClientFactory.create(), partitionField));\n        }\n        return callbacks;\n    }\n","description":"\nNote that the example is using a metastore client factory provided by the catalog environment. This can be used to add a partition tag callback, which will automatically handle adding partitions with a specific field name from the Hive metastore."},"name":"createTagCallbacks","code":"@Override\n    public List<TagCallback> createTagCallbacks() {\n        List<TagCallback> callbacks = new ArrayList<>(CallbackUtils.loadTagCallbacks(options));\n        String partitionField = options.tagToPartitionField();\n        MetastoreClient.Factory metastoreClientFactory =\n                catalogEnvironment.metastoreClientFactory();\n        if (partitionField != null && metastoreClientFactory != null) {\n            callbacks.add(\n                    new AddPartitionTagCallback(metastoreClientFactory.create(), partitionField));\n        }\n        return callbacks;\n    }","location":{"start":260,"insert":260,"offset":" ","indent":4,"comment":null},"item_type":"method","length":12,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."},{"id":"91e210ee-4aa9-eda1-1d49-ecf659f66a75","ancestors":["ad95a488-eb71-63ba-9f4d-e3cdcce686f6"],"type":"function","description":"creates a new instance of `ServiceManager`, which is used to manage services for the application. The new instance is created by calling `new ServiceManager(fileIO, options.path())`.","params":[],"returns":{"type_name":"ServiceManager","description":"a new instance of `ServiceManager` initialized with `fileIO` and the path specified in the `options` object.\n\n* The output is of type `ServiceManager`, indicating that it is a manager for services.\n* The `fileIO` parameter is used to create a new instance of the `FileIO` class, which provides functionality for interacting with files.\n* The `options.path()` method call returns a string representing the path to the directory where the services will be stored.","complex_type":true},"usage":{"language":"java","code":"ServiceManager serviceManager = fileStore.newServiceManager();\nserviceManager.start();\n// do something with the service manager\nserviceManager.stop();\n","description":"\nThe example code will create a ServiceManager object and then start it, after which you can use it to perform operations on the FileStore such as creating a new commit. Afterwards, you can stop the ServiceManager to free up resources."},"name":"newServiceManager","code":"@Override\n    public ServiceManager newServiceManager() {\n        return new ServiceManager(fileIO, options.path());\n    }","location":{"start":273,"insert":273,"offset":" ","indent":4,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"An abstract class called AbstractFileStore, which is a central component in a data storage system. It provides a high-level interface for managing various aspects of file storage, including path creation, snapshot management, manifest file handling, and more. The code also defines several methods for creating and managing files, such as newIndexFileHandler() and newStatsFileHandler(), which are used to handle specific file types. Additionally, the code includes a summary of what all of the above code does in a high-level manner, providing a brief overview of the main functions and classes defined in the code."}]}}}